#!/usr/bin/env ruby

require 'crowdin-cli'

# GLI_DEBUG=true bundle exec bin/crowdin-cli

# Return +hierarchy+ of directories and files in Crowdin project
#
# +files+ - basically, it's project files details from API method `project_info`
#
def get_remote_files_hierarchy(files, root = '/', hierarchy = { dirs: [], files: [] })
  files.each do |node|
    case node['node_type']
    when 'directory'
      hierarchy[:dirs] << "#{root}#{node['name']}"
      get_remote_files_hierarchy(node['files'], root + node['name'] + '/', hierarchy)
    when 'file'
      hierarchy[:files] << "#{root}#{node['name']}"
    end
  end

  return hierarchy
end

# Return +hierarchy+ of local directories and files
#
# @params [Array] files a list of files in a local directory.
#
def get_local_files_hierarchy(files, hierarchy = { dirs: [], files: [] })
  hierarchy[:files] = files

  dirs = files.inject([]) do |res, a|
    res << a.split('/').drop(1).inject([]) do |res, s|
      res << res.last.to_s + '/' + s
    end
  end
  dirs.map(&:pop) # delete last element from each array
  hierarchy[:dirs] = dirs.flatten.uniq

  return hierarchy
end

# @param [String] path relative path to file in Crowdin project
# @param [String] export_pattern basically, is a file['translation'] from crowdin.yaml
# @param [Hash] lang language information
# @option lang [String] :name
# @option lang [String] :crowdin_code
# @option lang [String] :iso_639_1
# @option lang [String] :iso_639_3
# @option lang [String] :locale
#
def export_pattern_to_path(path, export_pattern, lang, languages_mapping = nil)
  original_path      = File.dirname(path)
  original_file_name = File.basename(path)
  file_extension     = File.extname(path)[1..-1]
  file_name          = File.basename(path, File.extname(path))

  pattern = {
    '%language%'               => lang['name'],
    '%two_letters_code%'       => lang['iso_639_1'],
    '%three_letters_code%'     => lang['iso_639_3'],
    '%locale%'                 => lang['locale'],
    '%locale_with_underscore%' => lang['locale'].gsub('-', '_'),
    '%android_code%'           => android_locale_code(lang['locale']),
    '%original_file_name%'     => original_file_name,
    '%original_path%'          => original_path,
    '%file_extension%'         => file_extension,
    '%file_name%'              => file_name,
  }

  placeholders = pattern.inject([]){ |memo, h| memo << h.first[/%(.*)%/, 1] }

  unless languages_mapping.nil?
    pattern = Hash[pattern.map{|placeholder, str| [
      placeholder,
      (languages_mapping[placeholder[/%(.*)%/, 1]][lang['crowdin_code']] rescue nil) || str]
    }]
  end

  export_pattern.gsub(/%(#{placeholders.join('|')})%/, pattern)
end

def android_locale_code(locale_code)
  locale_code = case locale_code
    when 'he-IL' then 'iw-IL'
    when 'yi-DE' then 'ji-DE'
    when 'id-ID' then 'in-ID'
    else locale_code
  end
  return locale_code.sub('-', '-r')
end

def get_invalid_placeholders(export_pattern)
  valid_placeholders = [
    '%language%',
    '%two_letters_code%',
    '%three_letters_code%',
    '%locale%',
    '%locale_with_underscore%',
    '%android_code%',
    '%original_file_name%',
    '%original_path%',
    '%file_extension%',
    '%file_name%',
  ]

  all_placeholders = export_pattern.scan(/%[a-z0-9_]*?%/)
  invalid_placeholders = all_placeholders - valid_placeholders
end

# Return a string representing that part of the directory tree that is common to all the files
#
# @params [Array] paths set of strings representing directory paths
#
def find_common_directory_path(paths)
  return paths.first.split('/').slice(0...-1).join('/') if paths.length <= 1
  arr = paths.sort
  first = arr.first.split('/')
  last = arr.last.split('/')
  i = 0
  i += 1 while first[i] == last[i] && i <= first.length
  first.slice(0, i).join('/')
end

def unzip_file(zip, dest, files_list)
  # overwrite files if they already exist inside of the extracted path
  Zip.options[:on_exists_proc] = true

  unmatched_files = []

  Zip::ZipFile.open(zip) do |zip_file|
    zip_file.select{ |f| f.file? }.each do |f|
      file = files_list[f.name]
      if file
        f_path = File.join(dest, file)
        FileUtils.mkdir_p(File.dirname(f_path))
        puts "Download: #{file}"
        zip_file.extract(f, f_path)
      else
        unmatched_files << f
      end
    end
  end

  unless unmatched_files.empty?
    puts "Warning: Downloaded translations does not match current project configuration. Some of the resulted files will be omitted."
    unmatched_files.each{ |file| puts " - `#{file}'" }
    puts "Crowdin has internal caching mechanisms that prevents us from overload. Please try to download translations later."
  end
end

###
include GLI::App

version Crowdin::CLI::VERSION

program_desc 'is a command line tool that allows you to manage and synchronize your localization resources with Crowdin project'
program_long_desc 'This tool requires configuration file to be created. See http://crowdin.net/page/cli-client for more details.'
sort_help :manually # help commands are ordered in the order declared
wrap_help_text :to_terminal

desc 'Be verbose'
switch [:v, :verbose]

desc 'Configuration file'
default_value File.join(Dir.pwd, 'crowdin.yaml')
arg_name '<s>'
flag [:c, :config]

desc 'Allows you to upload source files and existing translations to Crowdin project'
long_desc 'This command is used to upload source files and translations to Crowdin. This command is used in combination with sub-commands `sources` and `translations`.'

command :upload do |c|

  c.desc 'safely upload source files to Crowdin'
  c.long_desc <<EOS
Upload source files to Crowdin project. If there are new localization files locally they will be added to Crowdin project.
Othervice files will be updated (if no --no-auto-update option specified).
EOS

  c.command :sources do |c|

    c.desc 'Defines whether to update source files in Crowdin project. --no-auto-update is useful when you just want to upload new files without updating existing ones.'
    c.switch ['auto-update']

    c.action do |global_options, options, args|
      project_info = @crowdin.project_info

      source_language = project_info['details']['source_language']['code']

      # Crowdin supported languages list
      supported_languages = @crowdin.supported_languages
      source_language = supported_languages.find{ |lang| lang['crowdin_code'] == source_language }

      remote_project_tree = get_remote_files_hierarchy(project_info['files'])

      local_files = []
      dest_files = []

      @config['files'].each do |file|
        get_invalid_placeholders(file['translation']).each do |placeholder|
          puts "Warning: #{placeholder} is not valid variable supported by Crowdin. See http://crowdin.net/page/cli-client#configuration-file for more details."
        end

        if File.exist?("#{@base_path}#{file['source']}")
          dest_files << file['source']

          local_file = { dest: file['source'], source: "#{@base_path}#{file['source']}", export_pattern: file['translation'] }
          # Used only when uploading CSV file to define data columns mapping.
          local_file.merge!({ sheme: file['scheme'] }) if file.has_key?('scheme')
          local_file.merge!({ first_line_contains_header: file['first_line_contains_header'] }) if file.has_key?('first_line_contains_header')

          local_files << local_file
        else
          Dir.glob("#{@base_path}#{file['source']}").each do |source|
            dest = source.sub("#{@base_path}", '') # relative path in Crowdin
            dest_files << dest

            file_pattern = export_pattern_to_path(dest, file['translation'], source_language)

            diff = (dest.split('/') - file_pattern.split('/')).join('/')
            export_pattern = file['translation'].sub('**', diff)

            local_file = { dest: dest, source: source, export_pattern: export_pattern }
            local_file.merge!({ sheme: file['scheme'] }) if file.has_key?('scheme')
            local_file.merge!({ first_line_contains_header: file['first_line_contains_header'] }) if file.has_key?('first_line_contains_header')

            local_files << local_file
          end
        end # if
      end # @config['files']

      if dest_files.empty?
        exit_now!("nothing to upload. See http://crowdin.net/page/cli-client#configuration-file for more details.")
      end

      common_dir = find_common_directory_path(dest_files)

      local_project_tree = get_local_files_hierarchy(local_files.collect{ |h| h[:dest].sub(common_dir, '') })

      local_files.each{ |file| file[:dest].sub!(common_dir, '') }

      # Create directory tree
      #
      create_dirs = local_project_tree[:dirs] - remote_project_tree[:dirs]
      create_dirs.each do |dir|
        puts "Create directory `#{dir}`"
        @crowdin.add_directory(dir)
      end

      if options['auto-update'].nil? or options['auto-update']
        # Update existing files in Crowdin project
        #
        # array containing elements common to the two arrays
        update_files = local_project_tree[:files] & remote_project_tree[:files]
        files_for_upload = local_files.select{ |file| update_files.include?(file[:dest]) }
        files_for_upload.each do |file|
          print "Updating file `#{file[:dest]}'"

          params = {}
          params[:scheme] = file.delete(:sheme)
          params[:first_line_contains_header] = file.delete(:first_line_contains_header)

          resp = @crowdin.update_file([] << file, params)
          case resp['files'].first[1]
          when 'skipped'
            puts "\rUpdating file `#{file[:dest]}' - Skipped"
          when 'updated'
            puts "\rUpdating file `#{file[:dest]}' - OK"
          end
        end
      end

      # Add new files to Crowdin project
      #
      add_files = local_project_tree[:files] - remote_project_tree[:files]
      files_for_add = local_files.select{ |file| add_files.include?(file[:dest]) }
      files_for_add.each do |file|
        print "Uploading file `#{file[:dest]}'"

        params = {}
        params[:scheme] = file.delete(:sheme)
        params[:first_line_contains_header] = file.delete(:first_line_contains_header)

        resp = @crowdin.add_file([] << file, params)
        puts "\rUploading file `#{file[:dest]}' - OK"
      end

    end # action
  end # command

  c.desc 'upload existing translations to Crowdin project'
  c.long_desc <<EOS
Upload existing translations to Crowdin.
See below available options that can be used in combination with this command.
If no options specified uploaded translations will be not approved,
imported to Crowdin project even if they are duplicated and imported even they are equal to souce string.
(In many localization formats they can be considered as not actually translations).
EOS
  c.command :translations do |c|

    c.desc 'Defines what language upload translations to. By default translations will be uploaded for all Crowdin project target languages'
    c.default_value 'all'
    c.arg_name 'crowdin_language_code'
    c.flag [:l, :language]

    c.desc 'Defines whether to add translation if there is the same translation already existing in Crowdin project'
    c.switch ['import-duplicates']

    c.desc 'Defines whether to add translation if it is equal to source string in Crowdin project'
    c.switch ['import-eq-suggestions']

    c.desc 'Automatically approve uploaded translations'
    c.switch ['auto-approve-imported']


    c.action do |global_options, options, args|
      params = {}
      params[:import_duplicates]     = options['import-dublicates']     ? 1 : 0
      params[:import_eq_suggestions] = options['import-eq-suggestions'] ? 1 : 0
      params[:auto_approve_imported] = options['auto-approve-imported'] ? 1 : 0

      language = options[:language]

      project_info = @crowdin.project_info

      remote_project_tree = get_remote_files_hierarchy(project_info['files'])

      if language == 'all'
        project_languages = project_info['languages'].collect{ |h| h['code'] }
      else
        project_languages = [] << language
      end

      supported_languages = @crowdin.supported_languages
      translation_languages = supported_languages.select{ |lang| project_languages.include?(lang['crowdin_code']) }

      source_language = project_info['details']['source_language']['code']
      source_language = supported_languages.find{ |lang| lang['crowdin_code'] == source_language }

      translated_files = Hash.new{ |hash, key| hash[key] = Array.new }
      dest_files = []

      @config['files'].each do |file|
        get_invalid_placeholders(file['translation']).each do |placeholder|
          puts "Warning: #{placeholder} is not valid variable supported by Crowdin. See http://crowdin.net/page/cli-client#configuration-file for more details."
        end

        languages_mapping = file['languages_mapping']

        if File.exists?("#{@base_path}#{file['source']}")
          dest = file['source'].sub("#{@base_path}", '')
          dest_files << dest

          translation_languages.each do |lang|
            source = export_pattern_to_path(dest, file['translation'], lang, languages_mapping)
            translated_files[lang['crowdin_code']] << { source: "#{@base_path}#{source}", dest: dest }
          end
        else
          Dir.glob("#{@base_path}#{file['source']}").each do |source|
            dest = source.sub("#{@base_path}", '') # relative path in Crowdin
            dest_files << dest

            file_pattern = export_pattern_to_path(dest, file['translation'], source_language)

            diff = (dest.split('/') - file_pattern.split('/')).join('/')
            export_pattern = file['translation'].sub('**', diff) # !!!

            translation_languages.each do |lang|
              source = export_pattern_to_path(dest, export_pattern, lang, languages_mapping)
              translated_files[lang['crowdin_code']] << { source: "#{@base_path}#{source}", dest: dest }
            end

          end
        end # if
      end # @config['files']

      if dest_files.empty?
        exit_now!("Warning: nothing to upload. See http://crowdin.net/page/cli-client#configuration-file for more details.")
      end

      common_dir = find_common_directory_path(dest_files)

      translated_files.each do |language, files|
        files.each do |file|
          file[:dest].sub!(common_dir, '')

          if remote_project_tree[:files].include?(file[:dest])
            if File.exist?(file[:source])
              print "Uploading `#{file[:source].sub(@base_path, '')}'"
              @crowdin.upload_translation([] << file, language, params)
              puts "\rUploading `#{file[:source].sub(@base_path, '')}' - OK"
            else
              puts "Warning: Local file `#{file[:source]}' does not exists"
            end
          else
            # if source file not exist, don't upload translation
            puts "Warning: Skip `#{file[:source].sub(@base_path, '')}'"
          end

        end
      end

    end # action
  end # command

end

desc 'Download latest translations from Crowdin and put them to the right places in your project'
#arg_name 'Describe arguments to download here'
command :download do |c|

  c.desc 'If the option is defined the translations will be downloaded for single specified language. Othervice (by default) translations are downloaded for all languages'
  c.arg_name 'language_code'
  c.flag :l, :language, :default_value => 'all'

  c.action do |global_options ,options, args|
    # use export API method before to download the most recent translations
    @crowdin.export_translations

    language = options[:language]
    project_info = @crowdin.project_info

    remote_project_tree = get_remote_files_hierarchy(project_info['files'])

    if language == 'all'
      project_languages = project_info['languages'].collect{ |h| h['code'] }
    else
      project_languages = [] << language
    end

    supported_languages = @crowdin.supported_languages
    translation_languages = supported_languages.select{ |lang| project_languages.include?(lang['crowdin_code']) }

    source_language = project_info['details']['source_language']['code']
    source_language = supported_languages.find{ |lang| lang['crowdin_code'] == source_language }

    # keys is all possible files in zip archive
    # values is resulted local files
    # usually they are equal
    downloadable_files = {}

    @config['files'].each do |file|
      languages_mapping = file['languages_mapping'] #Hash or NilClass

      if File.exists?("#{@base_path}#{file['source']}")
        dest = file['source'].sub("#{@base_path}", '')

        translation_languages.each do |lang|
          zipped_file = export_pattern_to_path(dest, file['translation'], lang)
          local_file  = export_pattern_to_path(dest, file['translation'], lang, languages_mapping)

          downloadable_files[zipped_file] = local_file
        end
      else
        Dir.glob("#{@base_path}#{file['source']}").each do |source|
          dest = source.sub("#{@base_path}", '') # relative path in Crowdin

          file_pattern = export_pattern_to_path(dest, file['translation'], source_language)

          diff = (dest.split('/') - file_pattern.split('/')).join('/')
          export_pattern = file['translation'].sub('**', diff)

          translation_languages.each do |lang|
            zipped_file = export_pattern_to_path(dest, export_pattern, lang)
            local_file  = export_pattern_to_path(dest, export_pattern, lang, languages_mapping)

            downloadable_files[zipped_file] = local_file
          end

        end
      end # if
    end # @config['files']

    ##
    file = Tempfile.new(language)
    path = file.path
    begin
      @crowdin.download_translation(language, :output => path)
      unzip_file(path, @base_path, downloadable_files)
    ensure
      file.close
      file.unlink # delete the temp file
    end
  end

end

pre do |global ,command, options, args|
  # Pre logic here
  # Return true to proceed; false to abourt and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only

  if File.exists?(global[:config])
    @config = YAML.load_file(global[:config])

    ['api_key', 'project_identifier'].each do |key|
      unless @config[key]
        exit_now! <<EOS
Configuration file misses required option `#{key}`

See http://crowdin.net/page/cli-client#configuration-file for more details
EOS
      end
    end

    unless @config['files']
      exit_now! <<EOS
Configuration file misses required section `files`

See http://crowdin.net/page/cli-client#configuration-file for more details
EOS
    end

  else
    exit_now! <<EOS
Can't find configuration file (default `crowdin.yaml').
Type `crowdin-cli help` to know how to specify custom configuration file

See http://crowdin.net/page/cli-client#configuration-file for more details
EOS
  end

  @config['files'].each do |file|
    file['source'] = '/' + file['source'] unless file['source'].start_with?('/')
    file['translation'] = '/' + file['translation'] unless file['translation'].start_with?('/')
  end

  if @config['base_path']
    @base_path = @config['base_path']
  else
    @base_path = Dir.pwd
    puts <<EOS
Warning: Configuration file misses parameter `base_path` that defines your project root directory. Using `#{@base_path}` as a root directory.
EOS
  end

  Crowdin::API.log = Logger.new($stderr) if global[:v]
  @crowdin = Crowdin::API.new(api_key: @config['api_key'], project_id: @config['project_identifier'], base_url: @config['base_url'] || 'http://api.crowdin.net')
  begin
    @crowdin.project_info
  rescue Crowdin::API::Errors::Error => err
    raise err
  rescue
    exit_now!("Seems Crowdin server API URL is not valid. Please check the `base_url` parameter in the configuration file.")
  end

  #puts "Executing #{command.name}" if global[:v]
  true
end

post do |global, command, options, args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
  #puts "Executed #{command.name}" if global[:v]
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)
